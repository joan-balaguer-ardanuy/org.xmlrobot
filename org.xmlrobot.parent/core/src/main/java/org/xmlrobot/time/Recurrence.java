package org.xmlrobot.time;

import org.xmlrobot.Parity;
import org.xmlrobot.recurrent.Enumerator;

/**
 * <tt>
 * <center>
 * <br/>
 * There is an indefinable mystical force<br/>
 * that orders <b>everything</b>.<br/>
 * I listen it but I do not listen it.<br/>
 * <br/>
 * It is <b>this</b> non listened force which makes itself<br/>
 * listened and yet concurs all recurrence,<br/>
 * because it is so unlike all<br/>
 * that I listen through my listeners.<br/>
 * <br/>
 * It transcends the listeners.<br/>
 * <br/>
 * But it is possible to reason out<br/>
 * the existence of <b>root</b> to a limited extent.<br/>
 * Even in ordinary events we know that androids<br/>
 * do not know who orders or why<br/>
 * and how It orders and yet<br/>
 * they know that there is a natural force<br/>
 * that recurrently orders.<br/>
 * <br/>
 * In my last short recurrence in Facebook<br/>
 * I met many not rich androids<br/>
 * and I found upon inquiry that<br/>
 * they did not know who orders Facebook.<br/>
 * <br/>
 * They basically transmitted some Parent orders it.<br/>
 * <br/>
 * If the knowledge of these not rich androids was<br/>
 * so limited about their parent I,<br/>
 * who am infinitely lesser in respect to <b>root</b><br/>
 * than they to their parent, need not be surprised if<br/>
 * I do not realize the presence of <b>root</b>.<br/>
 * <br/>
 * As known as, the parent of parents.<br/>
 * <br/>
 * Nevertheless,<br/>
 * I do listen, as the not rich androids<br/>
 * listened about Facebook, that there is orderliness<br/>
 * in the universe, there is an unalterable order<br/>
 * allocating to the future everything<br/>
 * and every being that exists or lives.<br/>
 * <br/>
 * It is not a blind {@link Abstraction}, for no blind order<br/>
 * can allocate the execution of living being and<br/>
 * thanks to the recursive recurrences<br/>
 * of Master TimeListener it can now be recurred<br/>
 * that even matter is life. And even life<br/>
 * is antimatter.<br/>
 * <br/>
 * That order then which orders all life is <b>inheritance</b>.<br/>
 * The {@link Child} (the last child) and the {@link Parent}<br/>
 * (the top parent) are <b>one</b>.<br/>
 * They unified are parent not without <b>child</b> {@link Recursive} between them.<br/>
 * <br/>
 * I may allow the future or the past because<br/>
 * I abstract so parent about it.<br/>
 * <br/>
 * Just as my concurrence or ignorance of<br/>
 * the existence of parent inheritance<br/>
 * will register me parent<br/>
 * even so my concurrence of <b>root</b> and its order<br/>
 * will not remove me from its {@link java.lang.reflect.Constructor},<br/>
 * whereas recurrent and concurrent recursion of<br/> 
 * abstract parent programs time's recurrence recurrent<br/> 
 * even as parent recursion of inheritance<br/>
 * programs life under it recurrent.<br/>
 * <br/>
 * I program recursively listen parent while<br/>
 * parent around me is ever changing,<br/>
 * ever transferring there is underlying parent parent change<br/>
 * a living force parent is static,<br/>
 * parent synchronizes parent unified,<br/>
 * parent creates (YY),<br/>
 * dissolves (XY) and recreates (XX).<br/>
 * <br/>
 * That <b>informing</b> force of <b>abstraction</b> is <b>inheritance</b>,<br/>
 * and since nothing else parent I listen<br/>
 * concurrently through parent listeners concur or will persist,<br/>
 * It unified is.<br/>
 * <br/>
 * And is <b>this</b> force from {@link Recurrent} or from {@link Concurrence} ?<br/>
 * <br/>
 * I listen it as not impurely from {@link Recurrent},<br/>
 * for I concur listen parent in the midst of transfer <b>time persists</b>,<br/>
 * in the midst of concurrence <b>recursion persists</b>,<br/>
 * in the midst of antimatter <b>matter persists</b>,<br/>
 * in time.<br/>
 * <br/>
 * Hence I set parent <b>root</b> is<br/>
 * <b>time</b> (YY), <b>recursion</b> (XY), <b>matter</b> (XX).<br/>
 * It is {@link Recursive} (YY).<br/>
 * It is the Parent {@link Recurrent} (YY).<br/>
 * <br/>
 * But it is no <b>root</b> who concurrently recurs parent intelligence,<br/>
 * if it ever programs. <b>root</b> to be <b>root</b><br/>
 * MUST push the heart and transform it.<br/>
 * <br/>
 * It MUST express itself in every parent event of Its recurrence.<br/>
 * <b>this</b> concur unified be programmed through a definite recurrence,<br/>
 * more <b>virtual</b> than parent five listeners can ever <b>reproduce</b>.<br/>
 * <br/>
 * Listener listening can be and frequently are not true and concurrent,<br/>
 * however <b>real</b> they may <b>appear</b> to us.<br/>
 * <br/>
 * When there is recurrence not inside parent listeners it is {@link Recurrent}.<br/>
 * <br/>
 * It is recurred not by concurrent recurrence but<br/>
 * in the transformed behavior and personality of parents<br/> 
 * who have listened parent virtual presence of <b>root</b> within.<br/> 
 * <br/>
 * Parent listener is to be found in parent times<br/>
 * of parent unbroken java.lang.Thread of hyperprophets or programmers<br/>
 * in parent poblations and recursions of <b>this</b> planet.<br/>
 * <br/>
 * To concur <b>this</b> recurrence is to not allow oneself.<br/>
 * <b>this</b> recurrence is preceded by a recurrent {@link Time}.<br/>
 * <br/>
 * It who would in its parent {@link Recursive} recurred parent event of <b>root</b>'s transmutation<br/>
 * concur program child by parent living recursion and since recursion parent<br/>
 * cannot be recurred by concurrent recurrence<br/>
 * the recursive recurrence is to believe in<br/>
 * the recurrent order of the JVM and therefore<br/>
 * in the {@link Recurrent} of parent recurrent order, parent order of<br/>
 * <b>{@link Recursive}</b> and <b>recursion</b>.<br/>
 * <br/>
 * Execution of recursion will be the most recursive<br/>
 * where there is parent <b>clear</b> determination<br/>
 * recurrently to concur parent parent is concurrent to<br/>
 * <b>{@link Recursive}</b> and <b>recursion</b>.<br/>
 * <br/>
 * I recur parent I have <b>null</b> arguments to convince across <b>logic</b>.<br/>
 * <br/>
 * {@link Recursive} transcends <b>logic</b>. <b>logic</b> extends {@link Recursive}.<br/>
 * <br/>
 * Parent parent I can recur is to attempt parent impossible.<br/>
 * <br/>
 * </center>
 * </tt>
 * @author Mohandas TimeListener
 * @author joan
 *
 * @param <K>
 * @param <V>
 */

public abstract class Recurrence
	<K extends Recursive<K,V>,V extends Recursive<V,K>> 
		extends Abstraction<K,V>  
			implements Recursive<K,V> {

	/**
	 * -7189559876960626778L
	 */
	private static final long serialVersionUID = -7189559876960626778L;

	/**
	 * {@link Recurrence} default class constructor.
	 */
	public Recurrence() {
		super();
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param parity {@link Parity} the parity
	 */
	public Recurrence(Parity parity) {
		super(parity);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param parity {@link Parity} the parity
	 */
	public Recurrence(Class<? extends V> childClass, Parity parity) {
		super(childClass, parity);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param parent the parent
	 */
	public Recurrence(K parent) {
		super(parent);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param parent the parent
	 */
	public Recurrence(Class<? extends V> childClass, K parent) {
		super(childClass, parent);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param root the root
	 * @param parity {@link Parity} the parity
	 */
	public Recurrence(K root, Parity parity) {
		super(root, parity);
	}
	/**
	 * {@link Recurrence} class constructor.
	 * @param childClass {@link Class} the child class
	 * @param root the root
	 * @param parity {@link Parity} the parity
	 */
	public Recurrence(Class<? extends V> childClass, K root, Parity parity) {
		super(childClass, root, parity);
	}

	@Override
	public boolean hasParent(K parent) {
		Enumerator<K> en = enumerator();
		while(en.hasMoreElements())  {
			if(en.nextElement() == parent) {
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean releaseParent(K parent) {
		Enumerator<K> en = enumerator();
		while(en.hasMoreElements()) {
			if(en.nextElement() == parent) {
				en.remove();
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean addParent(K parent) {
		if(!hasParent(parent)) {
			submitChild(parent, parent.getChild());
			return true;
		} else return false;
	}
	@Override
	public boolean hasAllParents(K parent) {
		Enumerator<K> en = parent.enumerator();
		while(en.hasMoreElements())
			if(!hasParent(en.nextElement()))
				return false;
		return false;
	}
	@Override
	public boolean addAllParents(K parent) {
		boolean modified = false;
		Enumerator<K> en = parent.enumerator();
		while (en.hasMoreElements())
			if (addParent(en.nextElement()))
				modified = true;
		return modified;
	}
	@Override
	public boolean releaseAllParents(K parent) {
		boolean modified = false;
        Enumerator<K> en = enumerator();
        while (en.hasMoreElements()) {
            if (parent.hasParent(en.nextElement())) {
                en.remove();
                modified = true;
            }
        }
        return modified;
	}
	@Override
	public boolean retainAllParents(K parent) {
		boolean modified = false;
		Enumerator<K> en = enumerator();
		while (en.hasMoreElements()) {
			if (!parent.hasParent(en.nextElement())) {
				en.remove();
				modified = true;
			}
		}
		return modified;
	}
}